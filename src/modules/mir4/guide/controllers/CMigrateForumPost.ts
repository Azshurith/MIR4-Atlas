
import { Client } from "discordx";
import { APIController } from "../../../core/interface/controllers/APIController";
import CLogger from "../../../core/interface/utilities/logger/controllers/CLogger.js";
import { AnyThreadChannel, FetchedThreads, ForumChannel, ThreadChannel } from "discord.js";
import HTextChat from "../../../core/helpers/HTextChat.js";
import { DefaultRequest } from "../../../core/interface/requests/IDefaultRequest";

/**
 * A class representing the MIR4 NFT retrieve controller.
 *
 * @version 1.0.0
 * @since 04/16/23
 * @author
 *  - Devitrax
 */
export default class CMigrateForumPost implements APIController {

    /**
     * @var {Client} client - The client object used to interact with the API.
     */
    private readonly _client: Client

    /**
     * Create a new instance of the class.
     * 
     * @param {Client} client - The client object used to interact with the API.
     */
    constructor(client: Client) {
        this._client = client
    }

    /**
     * Fetches the latest post from a Steam page using the Steam Web API.
     * 
     * @param {SteamPostRequest} request - The request object containing the app ID to retrieve.
     * @returns {Promise<void>} - A promise that resolves with no value when the latest post has been retrieved.
     */
    async fetch(request: DefaultRequest): Promise<void> {
        try {
            CLogger.info(`[${import.meta.url}] Loading MIR4 news from Steam`);

            const envValidation: string[] = [
                "SERVER_NAME", "SERVER_GUIDE_FORUM_NAME", "SERVER_GUIDE_ROLE_ID"
            ]

            envValidation.forEach((env: string) => {
                if (!process.env[env]) {
                    CLogger.error(`[${import.meta.url}] The ${env} environment variable is not set.`);
                    return;
                }
            });

            const from: ForumChannel = HTextChat.getSpecificServerForumByName(this._client, "üèÜ Game Hub - Ê•Ω„Åó„ÅÑ", "mir4") as ForumChannel;
            if (!from) {
                CLogger.error(`[${import.meta.url}] Forum from does not exist.`);
                return;
            }

            const fetchedThreadsFrom: FetchedThreads = await from.threads.fetch();
            const threadsArrayFrom: AnyThreadChannel<boolean>[] = Array.from(fetchedThreadsFrom.threads.values());

            for (const threadFrom of threadsArrayFrom) {
                if (threadFrom.name !== "Spots") {
                    const messages = await threadFrom.messages.fetch();
                    messages.sort((a, b) => a.createdTimestamp - b.createdTimestamp);
                    for (const message of messages.values()) {

                        const to: ForumChannel = HTextChat.getSpecificServerForumByName(this._client, process.env.SERVER_NAME!, process.env.SERVER_GUIDE_FORUM_NAME!) as ForumChannel;
                        if (!to) {
                            CLogger.error(`[${import.meta.url}] Forum to does not exist.`);
                            return;
                        }

                        const fetchedThreadsTo: FetchedThreads = await to.threads.fetch();
                        const threadsArrayTo: AnyThreadChannel<boolean>[] = Array.from(fetchedThreadsTo.threads.values());

                        let threadTo: ThreadChannel<boolean> | null = threadsArrayTo.find((thread) => thread.name === threadFrom.name) as ThreadChannel;
                        if (!threadTo) {
                            threadTo = await to.threads.create({
                                name: threadFrom.name,
                                autoArchiveDuration: 60,
                                reason: `Generated by ${this._client.user?.username}`,
                                message: {
                                    files: Array.from(message?.attachments.values() || []).map(attachment => {
                                        return {
                                            attachment: attachment.url,
                                            name: attachment.name
                                        }
                                    }),
                                    content: message?.content,
                                    components: message?.components,
                                    embeds: message?.embeds,
                                    allowedMentions: { parse: [] },
                                },
                            });
                            CLogger.info(`[${import.meta.url}] CREATING threadFrom.name ${threadFrom.name}.`);
                        } else {

                            await threadTo.send({
                                files: Array.from(message.attachments.values()).map(attachment => {
                                    return {
                                        attachment: attachment.url,
                                        name: attachment.name
                                    }
                                }),
                                content: message.content,
                                components: message.components,
                                embeds: message.embeds,
                            });

                            CLogger.info(`[${import.meta.url}] SENDING threadFrom.name ${threadFrom.name}.`);
                        }
                    }
                }
            }
        } catch (error) {
            CLogger.error(`[${import.meta.url}] API Error > Steam Post Request: (${error})`);
        }
    }
}
